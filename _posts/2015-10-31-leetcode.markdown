---
layout: post
title: leetcode-200-Number of Islands
category: leetcode
tags: [Algorithms]
---

# Number of Islands

## 一，想法

好吧，又有好一段时间没有开工咯。最近做一些项目，发现竟然用到了一些简单的算法问题，还好以前玩的时候写过。可以比较顺利的搞定。
想想也是挺有意思的，决定还是需要看看这些东西。打好基础，为未来做准备咯。

## 二，description

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

## 三，resolvent

说法比较明确，可以从头开始遍历，采用bfs，搜索到得点，置换一下状态。如果不是小岛，直接跳过。最后看一下遍历的次数即可。

## 四，code
<pre>
<code>
class Solution {
public:
    
    struct point {
        int x;
        int y;
    };
    
    int map[1000][1000];
    
    void bfs(vector<vector<char>>& grid, point r, int m, int n)
    {
        int sign[4][2] = {0,1,0,-1,1,0,-1,0};
        queue<point> q;
        q.push(r);
        point nextPoint;
        map[r.x][r.y] = 0;
        
        while(!q.empty())
        {
            point top = q.front();
            q.pop();
            grid[top.x][top.y] = 0;
            
            for(int i = 0; i < 4; ++i)
            {
                nextPoint.x = top.x+sign[i][0];
                nextPoint.y = top.y+sign[i][1];
                
                if(nextPoint.x >= 0 && nextPoint.x < m && nextPoint.y >= 0 && nextPoint.y < n && map[nextPoint.x][nextPoint.y] == 1)
                {
                    map[nextPoint.x][nextPoint.y] = 0;
                    q.push(nextPoint);
                }
            }
        }
    }
    
    int numIslands(vector<vector<char>>& grid) {
        
       if (grid.empty() || grid[0].empty()) return 0;
       int m = grid.size();
       int n = grid[0].size();
        
        for(int i = 0; i < m; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(grid[i][j] == '1') map[i][j] = 1;
                else map[i][j] = 0;
            }
        }
        
        int num = 0;
        for(int i = 0; i < m; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(map[i][j] == 0) continue;
                point k;
                k.x = i;
                k.y = j;
                bfs(grid, k, m, n);
                num++;
            }
        }
        return num;
    }
};
</code>
</pre>

