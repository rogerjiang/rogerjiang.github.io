---
layout: post
title: 从kmp算法看自身的不足点
category: 算法
tags: [算法]
---

# 关于kmp和自己的想法

## 一，想法

最近的一些工作中竟然用到了一些算法的东西，想想也是挺有意思，幸好以前写过一些，才能很快从这个角度出发，算法确实是一个基础，自己还是需要看看的。。。无意中看到了kmp算法，又重新让我有了那么一丝冲动。似乎多年前看过不少遍kmp，也写过不少遍kmp。但最后的结果还是发现
自己又一次把这个算法给忘得一干二净，除了知道一个大体的样子。
还是那句老话说得对，对于算法的这东西，记下来的或者背下来的，或者有疑问的。最后都会忘记的，所以还是要每个点都能想通才是
王道。这个算是深有体会，当初写bfs这东西，每次都是自己重新写一遍，久而久之，发现最近用到的时候，毫无压力的写出来。
感觉这个才算是真正的学习，不然纯属浪费时间，还搞得很高大上，想想真是醉咯。
最近突然对vr技术有兴趣，看看能不能搞点啥，还是一步一步走吧，路很多，路又很少。还是yy比较有感觉。

## 谈谈kmp

其实kmp这东西真不好理解，记得自己当初理解的时候，也推导过公式，也各种纸上画。终究还是不太理解。毕竟这个东西还是比较
抽象的。网上教程挺多的，可以看看Matrix67的KMP算法详解。也可以看看百度上各个blog的说法。
其实理解下来，我自己是感觉有一个东西一直不好理解。就是这句话“KMP的预处理本身就是一个B串“自我匹配”的过程”
这句话，大家都是这么说得，当然这句话我是背下来咯。但是还是不理解。
其实我们可以发挥一下对比的能力，毕竟这是一个人天生有的一个能力。我们来对比一下，我们用一个B字符串匹配A字符串的这个过程。
这里所谓的自我匹配，具体怎么对比呢。 
比如 a b c a b这个字符串. 已经知道0,1,2,3现在求4. 我们的比较是用1位置上的b与最后的一个b。比较发现是相等的。那
肯定为2咯。这里B字符串是 a b c a b,A字符串是a b...后面随意。 但是 我们发现了一个特点。
刚刚的例子是相等的，如果不相等，我们怎么办，按照匹配的方式，肯定是找next[1]。对头！就是这样。这样就可以看出来具体的A和B代表的是啥咯。
也算是比较好理解一点吧。

## kmp代码

顺便A掉了leetcode得strstr这个问题。
<pre>
<code>
class Solution {
public:

    int next[100000];

public:
    void nextValue(string A)
    {
        int n = A.length();
        next[0] = 0;
        int j = 0;
        for(int i = 1; i < n; ++i)
        {
             while(j > 0 && A[i] != A[j]) {
            j = next[j];
         }      
         
         if(A[i] == A[j]) {
            j++;
            next[i+1] = j;
         }
      }
    }

    int matchString(string A, string B)
    {
     int n = A.length();
     int m = B.length();
     int j = 0;
     
     for(int i = 0; i < n; ++i)
     {
       while(j > 0 && B[j] != A[i]) {
          j = next[j];
       }
       
       if(B[j] == A[i]) {
          j++;
       }
       
       if(j == m)
       {
           return (i-j+1);
           j = next[j];
       }
     }
      return -1;
    }
    

    int strStr(string haystack, string needle) {
        
       if(needle == "") return 0;
        
       nextValue(needle);
       return matchString(haystack, needle);
    }
};

</code>
</pre>

